import logging
from datetime import datetime
from typing import Optional

from models import InterviewSession, Resume, InterviewRound, Question, Answer
from question_service import generate_questions
from metrics import (
    record_round_start,
    record_round_completion,
    record_round_switch,
    record_answer_metrics,
    interview_sessions_completed,
    interview_sessions_active
)

logger = logging.getLogger("interview_service")

async def create_new_session(user_id: str, resume_id: str = None, session_type: str = "interview", job_title: str = "General Interview") -> InterviewSession:
    """Initialize a new interview session with all rounds pending"""
    session = InterviewSession(
        user_id=user_id,
        status="active",
        started_at=datetime.utcnow(),
        resume_id=resume_id,
        session_type=session_type,
        job_title=job_title
    )
    await session.insert()
    
    # Initialize rounds
    round_types = ["aptitude", "technical", "hr"]
    for r_type in round_types:
        round_obj = InterviewRound(
            session_id=str(session.id),
            round_type=r_type,
            status="pending"
        )
        await round_obj.insert()
        
    return session

async def initialize_all_rounds_questions(session_id: str, resume_text: str, job_title: str):
    """Generate questions for all rounds at once and cache them"""
    round_types = ["aptitude", "technical", "hr"]
    for r_type in round_types:
        # generate_questions now handles caching internally
        await generate_questions(resume_text, r_type, job_title)

async def activate_round(session_id: str, round_type: str, resume_text: str) -> dict:
    """Activate a round, generating questions if needed"""
    round_obj = await InterviewRound.find_one(
        InterviewRound.session_id == session_id,
        InterviewRound.round_type == round_type
    )
    
    if not round_obj:
        raise ValueError(f"Round {round_type} not found for session {session_id}")
        
    # Update Session
    session = await InterviewSession.get(session_id)
    session.current_round_id = str(round_obj.id)
    await session.save()
    
    # Update Round
    if round_obj.status == "pending":
        round_obj.status = "active"
        round_obj.started_at = datetime.utcnow()
        await round_obj.save()
        record_round_start(round_type)

    # Check for existing questions
    existing_questions = await Question.find(
        Question.round_id == str(round_obj.id)
    ).to_list()
    
    if not existing_questions:
        # Check if other rounds have questions already (might have been generated by bulk)
        all_rounds = await InterviewRound.find(InterviewRound.session_id == session_id).to_list()
        any_questions = False
        for r in all_rounds:
            count = await Question.find(Question.round_id == str(r.id)).count()
            if count > 0:
                any_questions = True
                break
        
        if not any_questions:
            # First time starting any round: Generate ALL rounds bulk (caching handles reuse)
            logger.info(f"First round activation for session {session_id}. Generating all rounds.")
            await initialize_all_rounds_questions(session_id, resume_text, session.job_title)
        
        # Now fetch again for this specific round
        existing_questions = await Question.find(
            Question.round_id == str(round_obj.id)
        ).to_list()
        
        # If still no questions (e.g. bulk generation failed or was first call), generate just this one
        if not existing_questions:
            generated_qs = await generate_questions(resume_text, round_type, session.job_title)
            
            for i, q_data in enumerate(generated_qs, 1):
                q_model = Question(
                    round_id=str(round_obj.id),
                    question_text=q_data["question"],
                    question_type=q_data.get("type", "descriptive"),
                    options=q_data.get("options"),
                    correct_answer=q_data.get("answer"),
                    starter_code=q_data.get("starter_code"),
                    test_cases=q_data.get("test_cases"),
                    language=q_data.get("language", "python"),
                    question_number=i
                )
                await q_model.insert()
                existing_questions.append(q_model)
            
    # Return current state
    return {
        "round_id": str(round_obj.id),
        "round_type": round_type,
        "questions": existing_questions,
        "current_question_index": round_obj.current_question_index
    }

async def process_answer(question_id: str, answer_text: str, time_taken: int) -> dict:
    """Process a submitted answer and update progress"""
    question = await Question.get(question_id)
    if not question:
        raise ValueError("Question not found")
        
    round_obj = await InterviewRound.get(question.round_id)
    session = await InterviewSession.get(round_obj.session_id)
    
    # Evaluate
    # Note: We likely need an evaluation service or import here. 
    # For now, simplistic evaluation for MCQs to keep this service clean, 
    # but descriptive needs AI.
    # We will import the legacy evaluate_answer for now or refactor it.
    from question_service import evaluate_answer as ai_evaluate
    
    evaluation = {}
    if question.question_type == "mcq":
        is_correct = answer_text.strip().lower() == str(question.correct_answer).strip().lower()
        evaluation = {
            "score": 10.0 if is_correct else 0.0,
            "evaluation": "Correct" if is_correct else f"Incorrect. Answer: {question.correct_answer}"
        }
    else:
        # Need resume context, fetching resume
        resume = await Resume.get(session.resume_id) if session.resume_id else None
        evaluation = await ai_evaluate(
            question.question_text, 
            answer_text, 
            resume.content if resume else "",
            round_obj.round_type
        )
        
    # Save Answer
    answer = Answer(
        question_id=question_id,
        answer_text=answer_text,
        evaluation=evaluation["evaluation"],
        score=evaluation["score"],
        time_taken_seconds=time_taken
    )
    await answer.insert()
    
    # Update Stats
    round_obj.total_time_seconds += time_taken
    round_obj.current_question_index += 1
    await round_obj.save()
    
    record_answer_metrics(round_obj.round_type, evaluation["score"], time_taken)
    
    return {
        "evaluation": evaluation,
        "round_obj": round_obj
    }

async def toggle_session_pause(session_id: str) -> dict:
    """Pause or resume an interview session"""
    session = await InterviewSession.get(session_id)
    if not session:
        raise ValueError("Session not found")
        
    now = datetime.utcnow()
    if session.is_paused:
        # Resume
        if session.last_pause_at:
            paused_duration = (now - session.last_pause_at).total_seconds()
            session.total_paused_time += int(paused_duration)
        session.is_paused = False
        session.status = "active"
        session.last_pause_at = None
    else:
        # Pause
        session.is_paused = True
        session.status = "paused"
        session.last_pause_at = now
        
    await session.save()
    return {
        "is_paused": session.is_paused,
        "status": session.status,
        "total_paused_time": session.total_paused_time
    }

async def get_full_session_state(session_id: str) -> dict:
    """Get the complete state of the interview for navigation"""
    session = await InterviewSession.get(session_id)
    if not session:
        raise ValueError("Session not found")
        
    rounds = await InterviewRound.find(InterviewRound.session_id == session_id).to_list()
    
    rounds_data = []
    for r in rounds:
        questions = await Question.find(Question.round_id == str(r.id)).sort("+question_number").to_list()
        
        qs_status = []
        for q in questions:
            ans = await Answer.find_one(Answer.question_id == str(q.id))
            status = "pending"
            if ans:
                status = ans.status if hasattr(ans, 'status') else "submitted"
            
            qs_status.append({
                "id": str(q.id),
                "number": q.question_number,
                "type": q.question_type,
                "status": status,
                "text": q.question_text,
                "options": q.options,
                "starter_code": q.starter_code,
                "language": q.language,
                "isCurrent": str(q.id) == session.current_question_id
            })
            
        rounds_data.append({
            "round_type": r.round_type,
            "round_id": str(r.id),
            "status": r.status,
            "questions": qs_status,
            "is_current": str(r.id) == session.current_round_id
        })
        
    return {
        "session_id": session_id,
        "status": session.status,
        "is_paused": session.is_paused,
        "total_time_seconds": session.total_time_seconds,
        "total_paused_time": session.total_paused_time,
        "rounds": rounds_data
    }
